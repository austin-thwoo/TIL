# OS 와 일반적인 지식
- [OS 와 일반적인 지식](#os-와-일반적인-지식)
  - [[1] 운영 체제란?](#1-운영-체제란)
    - [(1) 운영체제의 목적](#1-운영체제의-목적)
    - [(2) 부팅(Booting)](#2-부팅booting)
    - [(3) 운영 체제의 위치](#3-운영-체제의-위치)
  - [🔥[2] 리눅스 터미널 명령어 모음](#2-리눅스-터미널-명령어-모음)
  - [🔥[3] 운영체제의 구조 및 동작원리](#3-운영체제의-구조-및-동작원리)
    - [(1). 운영체제의 구조](#1-운영체제의-구조)
    - [(2).  운영체제의 동작원리](#2--운영체제의-동작원리)
      - [{1}. Dual-Mode Execution](#1-dual-mode-execution)
      - [{2}. Timer](#2-timer)
  - [🔥[4] 프로세스 관리](#4-프로세스-관리)
    - [(1). 프로세스](#1-프로세스)
      - [{1-1}. 프로세스 상태](#1-1-프로세스-상태)
      - [{1-2}. PCB(Process Control Block)](#1-2-pcbprocess-control-block)
      - [{1-3}. 프로세스 큐(Queue)](#1-3-프로세스-큐queue)
    - [(2). 멀티프로그래밍(Multiprogramming)](#2-멀티프로그래밍multiprogramming)
      - [{2.1}. Degree of multiprogramming](#21-degree-of-multiprogramming)
      - [{2.2}. I/O bound process VS CPU bound process](#22-io-bound-process-vs-cpu-bound-process)
      - [{2.3}. Medium-term scheduler](#23-medium-term-scheduler)
      - [{2.4}. Context Switching(문맥 전환)](#24-context-switching문맥-전환)
  - [🔥[5] 쓰레드](#5-쓰레드)
  - [🔥[6] 동시성과 병렬성 이해하기](#6-동시성과-병렬성-이해하기)
  - [🔥[7] 메모리 관리란? - 이유, 방법](#7-메모리-관리란---이유-방법)
  - [🔥[8] IPC란? - 정의, 종류, 방법](#8-ipc란---정의-종류-방법)
  - [🔥[9] OS - 입출력 관리](#9-os---입출력-관리)
  - [🔥[10] POSIX 기초](#10-posix-기초)
  - [🔥[11] 네트워크 기초 지식 정리](#11-네트워크-기초-지식-정리)
  - [🔥[12] 네트워크 기초 개념](#12-네트워크-기초-개념)
## [1] 운영 체제란?
운영체제(Operating System)는 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어이다. 우리가 일반적으로 컴퓨터를 사용하면서 실행한 모든 프로그램들은 운영체제에서 관리하고 제어한다.

대표적인 운영체제는 Windows, Linux, Mac OSX, iOS 등이 있다.
### (1) 운영체제의 목적
운영체제를 사용하는 가장 주된 목적은 __컴퓨터의 하드웨어를 관리__ 하는 것이다. 컴퓨터에는 수 많은 하드웨어가 존재한다. CPU, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크 등이 있으며 이를 잘 관리해주어야 컴퓨터를 효율적으로 사용할 수 있다. 운영체제의 성능이 좋을수록 컴퓨터의 성능 역시 좋아진다고 할 수 있다.

운영체제는 __사용자에게 편의를 제공__ 하는 목적도 가지고 있다. 운영체제가 없다면 위에서 말한 하드웨어에 관한 모든 관리를 사용자가 해야한다는 점과 같이 컴퓨터를 사용하는데 매우 불편함을 겪을 것이다. 하지만 현재 많은 발전을 거쳐온 운영체제가 설치된 컴퓨터는 사용하기에 매우 편리하다는 것을 느낄 수 있다. 대표적으로 스마트폰이 있다. 스마트폰 역시 컴퓨터의 일종이고 운영체제가 설치되어 있다. 그리고 스마트폰은 남녀노소 누구나 할 것 없이 사용법을 빠르게 익힐 수 있다.

정리하면 운영체제는 컴퓨터의 성능을 높이고(__performance__), 사용자에게 편의성 제공(__Convenience__)을 목적으로 하는 __컴퓨터 하드웨어 관리하는 프로그램__ 이다.
</br>

### (2) 부팅(Booting)
컴퓨터의 구조를 단순화하면 아래의 그림과 같다.
![picture/12001.png](back_flow/../picture/12001.png)
Processor는 일반적으로 CPU를 말한다. main memory를 보면 ROM과 RAM으로 나누어져 있다.

- ROM: 비휘발성 으로 메모리에서 극히 일부를 차지한다.(수 KB)
- RAM: 휘발성 으로 메모리의 대부분을 차지하며 실제 프로그램이 할당되는 곳이다.(수 MB ~ 수 GB)

ROM은 하드디스크와 같이 비휘발성으로 전원이 꺼져도 그 안의 내용이 계속 유지된다. RAM은 휘발성이므로 전원이 꺼지면 메모리안의 모든 내용이 지워진다.

컴퓨터의 전원이 켜지면 프로세서(CPU)에서 ROM에 있는 내용을 읽는다. ROM안에는 POST(Power-On Self-Test), 부트 로더(boot loader)가 저장되어 있다. POST는 전원이 켜지면 가장 처음에 실행되는 프로그램으로 현재 컴퓨터의 상태를 검사한다. POST 작업이 끝나면 부트 로더가 실행된다. 부트 로더는 하드디스크에 저장되어 있는 운영체제를 찾아서 메인 메모리(RAM)에 가지고 온다. 이러한 부트 로더의 과정을 부팅이라고 한다.
![picture/12002.png](back_flow/../picture/12002.png)
위 그림은 부트 로더가 진행하는 모습이다. 위와 같은 상태가 되면 운영체제가 수행할 준비를 마친 것이다. 운영체제가 종료하는 시점은 컴퓨터의 전원이 꺼지는 시점이다.

운영체제는 크게 __커널(kernel)__ 과 __명령어 해석기(Command interpreter, shell)__ 로 나뉜다.
![picture/12003.png](back_flow/../picture/12003.png)
</br>

### (3) 운영 체제의 위치

__사용자 프로그램(Application)__ 은 특정 운영체제에 맞춰서 만든다. 그러므로 한 애플리케이션은 서로 다른 운영체제에서 수행할 수 없다. (하드웨어가 같은 것은 전혀 상관이 없다.) 예를 들면 Windows에서 수행하는 프로그램을 그대로 Linux에 옮기면 수행되지 않는다.
![picture/13001.png](back_flow/../picture/13001.png)
애플리케이션은 위의 그림과 같이 운영체제 위에서 수행한다. 즉, 하드웨어 자원을 직접적으로 사용하지 않고 운영체제가 제공하는 자원만을 사용할 수 있다.

운영체제는 실제 세상의 정부(Goverment)와 유사하다. 정부가 하는 일은 다음과 같다.

- 국토, 인력, 예산과같은 자원이 존재하며 이를 효율적으로 사용해야한다.
- 효율적인 자원 관리를 위해 행정부, 국토부, 교육부, 국방부 등 부서로 나눠 관리한다.
- 각 부서들은 국민들에게 자원을 요청받고 적절히 배분한다.

운영체제가 하는 일은 다음과 같다.

- 프로세스, 메모리, 하드디스크 등 하드웨어 자원이 존재하고, 이를 효율적으로 사용해야한다.
- 자원 관리를 위해 프로세스 관리, 메모리 관리, 디스크 관리, 네트워크, 보안 등 기능이 나눠져 있다.
- 애플리케이션들의 요청에 따라 각 기능들이 수행하여 적절히 자원을 분배한다.


## 🔥[2] 리눅스 터미널 명령어 모음
 '터미널'은 사전적 의미로 종단, 끝을 의미한다. 
이 의미를 컴퓨터로 빗대어 보면 데이터를 송수신 하는 목적지나 출발점의 의미가 될 수 있다.
따라서 리눅스에서 사용하는 '터미널'은 명령을 내려 컴퓨터를 제어하는 곳이라고 생각하면 된다.


 
터미널 사용방법
 기초 터미널 명령어
grep, awk, sed, lsof, curl, wget, tail, head, less, find, ssh, kill
<hr>

 
__passwd [옵션] [계정]__
- 사용자 계정의 패스워드를 등록하거나 변경하는 경우 이용하는 명령어이다.
- 슈퍼 유저는 다른 유저의 패스워드도 변경 가능하다.

옵션
-S : 계정의 상태를 표시한다.(PS : 정상, NP : 패스워드가 없음, LK : Lock상태 혹은 NP 상태)
-d : 계정의 패스워드를 삭제한다. 패스워드 없이 로그인이 가능해진다.
-l : 계정을 Lock 상태로 변경한다.
-u : 계정의 Lock 상태를 해제한다.


<hr>

__ls [옵션] [파일명]__
- 현재 디렉토리 내의 파일과 디렉토리 정보를 출력한다.
- 윈도우 cmd 창의 'dir'과 같은 명령이다.
- [옵션]에는 -를 붙여 아래와 같은 옵션을 부여 할 수 있으며 두 개 이상의 옵션도 가능하다.
- [파일명]에는 파일명이나 디렉토리명을 적을 수 있다

옵션
-a : 디렉토리에 있는 모든 파일들(.으로 시작하는 파일 포함)을 출력한다.
-i : 파일의 아이노드(inode, 색인번호) 번호를 출력한다. 
-h : 파일 크기를 사람이 보기 쉬운 단위로 출력한다.(k : 킬로바이트, m : 메가바이트)
-l : 파일의 다양한 정보(상세정보)를 함께 출력한다.(소유자, 권한, 크기, 날짜)
-m : 파일을 쉼표로 구분하여 가로로 출력한다.
-s : kb 단위의 파일 크기를 출력한다.
-t : 최근 생성된 시간 순으로 파일을 출력한다.
-F : 파일 종류 별로 파일 끝에 특수 문자 표시.(일반파일 : 표시없음, 실행파일 : *, 디렉토리 : /, 심볼링크 : @, FIFO파일 : |, 소켓파일 : =)
-R : 지정한 디렉토리 아래에 있는 하위 디렉토리와 파일들을 포함하여 출력한다.
-S : 파일 크키가 큰 순서대로 출력한다.
--help : 도움말을 출력한다.


<hr>

__cd [디렉토리명]__
- Change Directory.
- 디렉토리를 이동할 때 사용한다.

옵션
cd [엔터], cd ~, cd ~/, cd $HOME : 사용자의 홈 디렉토리로 이동한다.
cd . : 현재 디렉토리로 이동한다.
cd / : 최상위 디렉토리로 이동한다.
cd $변수명 : 변수에 지정된 경로로 이동한다.
cd ~계정명 : 입력한 사용자의 홈디렉토리로 이동한다.
cd - : 이전 경로로 이동한다.

<hr>

__cp [옵션] [원본파일명] [대상파일명/디렉토리명]__
- 윈도우 cmd의 'copy' 명령과 같다.
- 하나 이상의 [원본파일]을 [대상파일]이나 [디렉토리]로 복사한다.
- [원본파일명]에는 하나 이상의 파일을 지정할 수 있다.

옵션
-i : 파일 복사 시, 동일한 파일명이 있을 경우 사용자에게 덮어 쓸 것인지 물어본다.
-f : 동일한 파일명이 있을 경우에도 강제로 지우고 복사한다.
-p : 원본 파일 소유주, 그룹, 권한, 시간 정보들이 그대로 보존되어 복사한다.
-r : [원본파일명]이 경로일 경우, 그 경로에 있는 모든 하위 디렉토리들을 포함하여 모두 복사한다. 일반 파일일 경우는 그냥 복사한다.
-u : 복사 대상이 이미 존재하며 파일의 날짜가 같거나 더 최신이면 복사하지 않는다.


<hr>

__mkdir [옵션] [파일명]__
- 새로운 디렉토리를 생성한다.
- 읽기 권한(Write Permission)이 허용되어야만 디렉토리를 생성할 수 있다.

옵션
-m : 디렉토리의 권한을 지정한다.(기본값 : 755) ex) mkdir -m 700 dir -> dir 디렉토리의 권한을 700으로 설정하여 생성한다.
-p : 생성하려는 디렉토리의 상위 디렉토리가 없는 경우 상위 디렉토리까지 같이 만든다.


<hr>

__rmdir [옵션] [파일명]__
- 빈 디렉토리를 제거한다.
- 읽기 권한(Write Permission)이 허용되어야만 디렉토리를 삭제할 수 있다.

옵션
-p : 상위 경로도 삭제한다.


<hr>

__mv [옵션] [원본파일] [대상파일]__
- 파일의 이름이나 위치를 변경할 때 사용한다.

옵션
-f : 이동할 위치에 파일 이름이 겹치면 강제로 이동한다.
-i : 이동할 위치에 파일 이름이 겹치면 사용자에게 물어본다.


<hr>

__find [디렉토리] [옵션]__
- 파일을 이름, 수정 날짜, 소유주, 허가 등을 기준으로 검색하게 해준다.

옵션
-empty : 비어있는 파일을 찾는다.
-user [사용자명] : 지정한 사용자가 소유하고 있는 파일을 찾는다.
-group [그룹명] : 지정한 그룹이 소유하고 있는 파일을 찾는다.
-nouser : 소유주가 없는 파일을 찾는다(사용자 계정을 삭제했을 경우 사용자가 생성한 파일들을 남기는 경우가 있다).
-nogroup : 소유그룹이 없는 파일을 검색한다.
-name [파일명] : 지정한 패턴을 갖는 파일을 찾는다(파일명 또는 확장명을 기준으로 검색한다).
-newer [파일명] : [파일명]보다 최근에 생성된 파일을 찾는다.
-anewer [파일명] : [파일명]보다 최근에 읽기(접근)가 수행된 파일을 찾는다.
-cnewer [파일명] : [파일명]보다 최근에 상태가 변경(수정)된 파일을 찾는다.
-perm [권한] : 권한과 일치하는 파일을 찾는다.
-type [파일타입] : [파일타입]에 맞는 파일을 찾는다. [파일타입]은 아래와 같다.
d : 디렉토리(Directory)
c : 캐릭터 특수 파일(Character Device)
f : 일반파일(File)
b : 블록 특수 파일(Block Device)
l : 심볼릭 링크(Link)
p : 파이프(Pipe)
s : 소켓(Socket)
-atime [+n/-n/n] : 최근 n일 이전에 access된 파일을 찾는다(Access Time).
+n : n일 전부터 접근하지 않은 파일
-n : n일 동안 접근한 파일
n : n일 전에 접근한 파일
-ctime [+n/-n/n] : 파일의 퍼미션(권한)을 마지막으로 변경한 파일을 찾는다(Changed Time).
+n : n일 전부터 퍼미션을 변경하지 않은 파일
-n : n일 동안 퍼미션을 변경한 파일
n : n일 전에 퍼미션을 변경한 파일
-mtime [+n/-n/n] : data를 마지막으로 수정한 파일을 찾는다.(Modified Time).
+n : n일 전부터 수정하지 않은 파일
-n : n일 동안 수정한 파일
n : n일 전에 수정한 파일
-size : 저장한 파일 크기로 파일을 찾는다.
-depth : 별도로 지정할 필요가 없으며 서브 디렉토리까지 찾는 옵션이다.
-mount : 다른 파일 시스템의 디렉토리는 검색하지 않는다.
-prune : 서브 디렉토리로 내려가지 않고 현재 디렉토리에서만 검색한다.
-samefile [파일명] : 링크된 파일을 찾는다(하드 링크).
-lname "*이름" : 링크된 파일을 찾는다(심볼릭 링크).
-inum [inode번호] : inode 번호로 파일을 찾는다.

<hr>


__head [-count] [파일이름], tail [-count] [파일이름]__
- head [-count] [파일이름] : 첫 번째 라인부터 number 라인까지 출력한다. 설정하지 않을 경우 10번째 라인까지 출력한다.
- tail [-count] [파일이름] : 마지막 라인부터 number 라인까지 출력한다. 설정하지 않을 경우 10번째 라인까지 출력한다.
- tail -f [파일이름] : 실시간으로 파일에 추가되는 내용을 확인한다. 보통 log파일을 관찰할 때 자주 사용한다.

<hr>

__cat [옵션] [파일이름]__
- 파일의 내용을 볼 수 있는 명령어이다.
- cat > [파일이름] 형태로 명령어를 작성했을 경우, 파일 생성 및 데이터 입력도 가능하다.
* 파일 저장 : Ctrl + d, 파일 종료 : Ctrl + z
- cat [파일명] | more : 엔터키를 입력할 때마다 한 줄씩 내려가면서 확인이 가능하다.
- cat [파일명] | less : 화살표 위, 아래키로 페이지 올림, 내림이 가능하다.
* more과 less 상태에서 q를 누르면 종료가 된다.

옵션
-n : 파일을 출력할 때, 라인에 번호를 붙여 출력한다.
-b : 공백 외의 글자가 있는 라인에 번호를 붙여 출력한다.


<hr>

__gzip [옵션] [파일명]__
- 리눅스에 설치되어 있는 기본 압축 프로그램이다.
* gzip 명령어를 찾을 수 없다고 나온다면, 'apt-get install gzip' 으로 설치하면 된다.
- 리눅스에서 사용하는 압축 프로그램이다.
- 속도나 압축률 면에서 상당히 좋은 프로그램이다.
- 파일을 압축할 경우 사용하는 명령어이다.
- 압축된 파일은 .gz라는 확장자를 갖는다.
- 성공적으로 압축이 수행되었을 경우, 압축을 수행한 원본 파일은 삭제된다.


옵션
-d : 압축을 해제한다(Decompress).
-f : 압축을 하거나 해제할 때, 같은 이름의 파일이 존재할 경우 덮어쓰기 한다.
-l : 압축 파일의 정보를 보여준다.
-r : 압축 파일의 디렉토리까지 압축을 수행한다.


<hr>

__tar [옵션] [파일명]__
- 여러 파일을 하나로 묶을 경우 사용되는 명령어이다.
- 확장자는 .tar 이다.

옵션
-c : 파일을 tar로 묶어 생성한다.
-x : 기존의 tar파일의 압축을 해제할 경우 사용한다.
-v : 압축할 때나 압축을 해제할 때, 과정을 화면으로 출력한다.
-f : 파일 이름을 지정한다.
-C : 파일 경로를 지정한다.
-z : gzip으로 압축하거나 해제한다.


<hr>

__kill [시그널 번호/시그널 이름] [프로세스]__
- 특정 프로세스에 특정한 Signal을 보내는 명령어이다.
- 보통 실행중인 프로세스를 종료시키고자 할 때 사용한다.
- 가끔 중지시킬 수 없는 프로세스가 발생하는 경우가 있는데, 이때 강제 종료 시키기 위해 kill 명령어를 사용한다.

옵션
-i : 프로세스 종료 전 사용자에게 물어본다.
-v : 진행 현황을 확인 할 수 있다.
-w : 지정한 프로세스들이 모두 종료 될 때까지 종료 시도를 한다.

<hr>

__su [-] [사용자ID]__
- 다른 사용자 계정으로 서브 쉘을 생성하는 명령어이다.
- 현재 계정을 로그아웃 하지 않고 다른 계정으로 전환 할 때 사용한다.
- su는 'Super User'가 아니며 'Substitute User'를 의미한다.
- su만 입력했을 경우, su root와 같다.

옵션
-c : 쉘을 실행하지 않고 주어진 명령만 수행한다.
-, -l, -login : 지정한 사용자의 환경변수를 적용해 로그인한다.
-s : 지정된 쉘로 로그인한다.

<hr>

__shutdown [옵션] 시간 [메시지]__
- halt, init과 함께 시스템을 종료하는 명령어 중 하나이다.
- [메시지]를 통해 현재 접속 중인 모든 사용자에게 시스템이 종료된다는 메시지를 보낼 수 있다.

옵션
-r : 시스템 종료 후 재 부팅한다.
-h : shutdown이 완료된 후 시스템을 종료한다.
-c : 진행 중인 shutdown 명령어를 취소한다.
-k : 경고 메시지만 출력하고 실제로는 shutdown 하지 않는다('Just Kidding'의 의미).


[basic command description](https://www.thomas-krenn.com/en/wiki/Cmd_commands_under_Windows)

## 🔥[3] 운영체제의 구조 및 동작원리
### (1). 운영체제의 구조
예전 DOS 시절 운영체제에서는 자원의 효율성이 굉장히 떨어졌었는데요.


예전에는 메모리에 여러 가지  작업들이 올라가지 못하였습니다. 
예를 들어 수행해야 할 작업-1과 작업-2가 있다고 생각해봅시다.

작업-1은 CPU를 사용한 후 I/O 장치를 사용하고,
작업-2는 CPU만을 사용하는 작업이라고 예를 들어 보겠습니다.

작업-1이 먼저 수행이 되면서 CPU를 사용하고 I/O를 사용하는 동안 CPU는 놀고 있음에도 불구하고 작업-2는 메모리에 올라가있지 않기 때문에 작업-1의 전체적인 작업이 끝나기 전까지 작업을 시작하지 못하였습니다. (  I/O 장치를 사용할 때도 마찬가지입니다. )
이러한  유연하지 않은 구조는 컴퓨터 전체의 효율성을 떨어뜨렸습니다. 
그래서 생각해낸 것이 CPU와 I/O를 바쁘게 하자!이고 그것이 바로 Multiprogramming입니다.

</br>
- ####  {1-1}. Multiprogramming

  - Multiprogramming은 여러 작업들이 동시에 메모리에 올라가게 됩니다.
그리고 위와 같이 작업-1이 수행되는 동안 CPU가 대기 상태로 들어가고 I/O를 수행할 때 작업-2는 
대기 상태인 CPU를 사용하게 함으로써 유연성을 제공하여 효율성을 높이는 방법입니다. 반대로 I/O가 대기 상태일 때는
I/O가 필요한 작업에게 그 자원을 할당해줍니다.

</br>
- ####  {1-2}. Multitasking

  - Multiprogramming에도 단점이 있었는데요! 그것은 바로 작업들마다 자원의 사용에 시간 차이가 생기기 때문입니다.
예를 들어보겠습니다. 만약에 작업-1이 CPU를 사용하고 I/O를 사용하게 되면 CPU는 작업-2에게 할당되어 작업-2는 
CPU를 사용하게 됩니다. 하지만 만약 작업-1의 I/O 사용시간이 길어지면 작업-2가 CPU를 이용한 작업을 끝내도 I/O 작업으로 
들어가지 못하고 계속 대기하게 됩니다. 그럼 이때도 역시 위와 마찬가지의 CPU 자원의 낭비가 일어나게 되는 것입니다. 
이러한 낭비는 효율성을 떨어뜨리는 결과를 가져옵니다.

그래서 등장한 것이 Multitasking입니다.
Multitasking은 Multiprogramming의 논리의 확장이라고 보면 됩니다.
각각의 작업에 시간을 부여하고 CPU를 작업하다가 그 시간이 지나가면 다른 작업에게 CPU 자원을 할당해줍니다.
그러므로 위와 같은 시간 지연으로 인한 낭비를 줄일 수 있으며 주어 진 시간은 굉장히 짧아서 빈번한 switching이 발생하게 됩니다.

 1. 만약 여러 작업들이 메모리에 올라갈 준비가 되어있다면 Job Scheduling을 통해 메모리에 올리고
 2. 메모리에 올라와 있는 여러 작업들이 실행될 준비가 되어있다면 CPU Scheduling을 통해 조정합니다
 3. 그리고 작업의 process가 메모리에 맞지 않는다면 swapping out되어 다른 작업이 swapping in 됩니다.

</br>
### (2).  운영체제의 동작원리

운영체제는 이전 포스팅에서 설명하였듯이 interrupt(event)-driven 방식입니다.
-  1. H/W interrupts
-  2. S/W interrupts - trap( or exception)
      - S/W errors : 흔히 프로그래밍하면서 나올 수 있는 error ( divide by zero, stack overflows...)
      - 운영체제 services 들에 대한 요청 -> System Call 

운영체제는 한 작업의 error로 인해 자원을 계속해서 점유하는 일과같이 효율성과 컴퓨터의 동작을 저해하는 행위를
보호해야 할 수단을 필요로 합니다. 그러한 방법에는 크게
 Dual-Mode Execution, Timer 
두 가지가 존재합니다. 

</br>
#### {1}. Dual-Mode Execution

조건은 H/W의 지원이 요구됩니다. 시스템을 보다 안전하게 하는 것이 목표이죠.
이 방법은 Mode-Bit라는 것을 필요로 하는데, Mode에는 Kernel Mode와 User Mode 두 가지가 있습니다.

프로그램이 메모리에 올라가서 작업들을 수행할 때 명령어들을 하나씩 읽어와 수행하게 되는데요
하지만 사용자가 Kernel 상의 작업, 즉 컴퓨터의 Core에 해당하는 작업들을 직접 건드려 명령하고 수행을 하게 된다면
자칫 잘못하다는 시스템 전체에 큰 악영향을 끼칠 수 있게 됩니다. 그것을 방지하고자 이러한 방법을 도입하게 되었는데요

각각 명령어에 Mode-bit를 심어 해당 명령어의 Mode-bit와 현재 시스템 상의 Mode-bit가 
같을 시에만 해당 명령어를 수행하게끔 하는 것입니다.  
예를 들어보겠습니다.
```
printf("출력");
```

위의 코드는 C에서 콘솔 창에 특정 문구를 출력하는 코드입니다.
모니터를 통해 콘솔 창에 출력하는 행위는 I/O를 이용하여 출력을 하게 됩니다.
이러한 I/O 작업은 OS만 접근이 가능해야 하는데요.
위의 함수의 내용을 열어보면 여러 가지 명령어들이 있고 그중에 INT 80이라는 명령어를 찾아볼 수 있습니다.
위의 명령어는 특수 명령어로서 현재 Mode를 바꿔주는 역할을 합니다. 
즉 이전까지 수행되던 명령어들은 User-Mode였다면 화면에 출력하기 위해서는 Kernel-Mode가 필요하므로 
위의 명령어를 통해 Mode를 Kernel-Mode로 변환 후 I/O 장치에 출력을 하는 명령을 OS가 내리게 됩니다.
그리고 함수가 끝날 때는 다시 User-Mode로 돌아게 되겠죠!

이러한 bit를 바꾸는 행위를 System-Call이라고 합니다. 굉장히 중요한 개념이죠!
이렇게 Kernel에서 수행되어야 하는 몇 가지 중요한 명령어들이 있습니다. 위에서 언급한 운영체제의 Services들이죠
그 예를 들어보자면
  1. Turn off interrupts 
  2. Access I/O devices 
  3. Set value of timer
등이 있고 이외에도 여러 가지 명령어들이 있습니다.

System Call이 일어나게 되면 앞선 포스팅에서 Interrupt Vector Table과 Interrupt Vector Routine의 동작원리와 같이
해당 System Call에 대한 번호를 Table에서 찾아 Routine을 실행하게 됩니다. 이러한 작업은 운영체제에서 일어나게 되죠.
밑의 사진은 System Call의 이해를 조금 더 도울 수 있을 것 같습니다.
![picture/32001 .png](back_flow/../picture/32001.png)


</br>
#### {2}. Timer

Timer는 간단하게 설명해드리겠습니다. 이름에서 와 닿듯이 Timer는 infinite loop 나 자원의 독점을 막습니다.
Timer는 특정 시간이 지나면 Interrupt를 발생시키고 운영체제는 그 시간을 감소시키면서 Interrupt를 기다립니다.
운영체제는 Timer가 끝난 작업을 종료시키고 또한 실행되기 전 Scheduling 작업 전에 Timer를 작동시킵니다.
확실히 Dual-Mode Execution보다는 쉽게 와 닿으실 거라고 기대해봅니다
이제 전체적으로 정리를 해보고 중요한 것은 조금 더 알아보는 시간을 갖도록 하겠습니다!

운영체제는 무슨 일을 하는가!
  1. Process management
  2. Memory management
  3. Storage management
  4. Protection and Security

Program vs Process
 Program은 현재 Memory에 올라와 있는 Process들 중 실행 중인 Process입니다.
  Process는 CPU time, Memory, files, I/O 등 여러 자원을 필요로 합니다.
  
운영체제의 Process Management 
  - Process와 Thread의 CPU 위의 작업들을 Scheduling.
 - User와 System의 Process를 생성하거나 삭제.
  - Process의 동기화 작업이나 Communication 작업의 mechanisms을 제공. 

운영체제의 Memory Management
  - 명령어들이 순서에 맞게 실행되도록 관리.
  - 모든 Data들이 실행되기 전 Memory에 올라갈 수 있도록 관리.
  - Memory 공간을 할당하고 회수.
  - 언제 어떤 것이 Memory에 올라갈지 결정.

운영체제의 Services
  사용자에게 도움을 주는 Services
- UI 제공
- I/O 작업 수행
- Error Detection
- 파일 시스템 관리
시스템의 운영의 효율성을 제공하는 Services
- 자원(Resources) 할당
- Accounting
- Protection & Security

System Call
직접적으로 사용하지 않으며 High-Level Language로 작성된 API가 제공된다.
각 System Call에 대한 번호와 루틴은 Table의 형태로 저장된다.
루틴이 끝난 뒤 System Call의 상태와 결괏값을 반환한다.

-직접 System Call을 만들어보는 방법-
1. System Call 함수 정의
2. System Call 번호 할당
3. System Call 함수 Table에 등록
4. Kernel Rebuild & Test

System Call의 종류
- Process Control
- File Manipulation
- Device Manipulation
-Information Maintenance
- Communication
-Protection

## 🔥[4] 프로세스 관리

### (1). 프로세스
프로세스는 메인 메모리에 할당되어 **실행중인 상태**인 프로그램을 말한다. 프로그램은 일반적으로 하드디스크(보조기억장치)에 저장되어 아무 일도 하지 않는 상태이다. 프로세스는 실행하면서 stack pointer, data, text, register 등이 끊임없이 변한다. 프로세스는 job, task 등으로 불리기도 한다.

</br>
#### {1-1}. 프로세스 상태
- New : 프로그램이 메인 메모리에 할당된다.
- Ready : 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친다.
- Running : CPU가 해당 프로세스를 실행한다.
- Waiting : 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 한다. (해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready 상태로 돌아가야 한다.)
- Terminated : 프로세스가 완전히 종료된다.
![picture/41101 .png](back_flow/../picture/41101.png)
위 그림은 **프로세스 상태 전이도**의 모습이다. new에서부터 프로세스가 어떤 작업에 의해 상태가 변하는지 나타낸다. running에서 ready로 변할 때는 time sharing system에서 해당 프로세스가 CPU시간을 모두 소진하였을 때 인터럽트에 의해 강제로 ready상태로 변하고, CPU는 다른 프로세스를 실행시킨다.

</br>

#### {1-2}. PCB(Process Control Block)

PCB는 프로세스에 대한 모든 정보가 모여있는 곳으로, Task Control Block(TCB) 이라고도 한다. PCB안에는 프로세스의 상태, 프로세스 번호(PID), 해당 프로세스의 program counter(pc), register값, MMU정보, CPU점유 시간 등이 포함되어 있다. PCB는 운영체제 내부의 프로세스를 관리하는 코드 부분에 저장되어 있다.
![picture/41201 .png](back_flow/../picture/41201.png)
CPU는 한 프로세스가 종료될 때까지 수행하는 것이 아니라 여러 프로세스를 중간 중간에 바꿔가면서 수행한다. 그러므로 CPU는 수행중인 프로세스를 나갈 때, 이 프로세스의 정보를 어딘가에 저장하고 있어야 다음에 이 프로세스를 수행할 때 이전에 수행한 그 다음부터 이어서 작업할 수 있다. 이러한 정보를 저장하는 곳이 PCB이다.

</br>

#### {1-3}. 프로세스 큐(Queue)
프로세스는 수행하면서 상태가 여러 번 변하는데 이에 따라 서비스를 받아야하는 곳이 다르다. 그리고 프로세스는 일반적으로 여러 개가 한 번에 수행되므로 그에 따른 순서가 필요하다. 이러한 순서를 대기하는 곳을 **큐(queue)**라고 부른다.
![picture/41301 .png](back_flow/../picture/41301.png)
- Job Queue : 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐이다.
- Ready Queue : CPU 점유 순서를 기다리는 큐이다.
- Device Queue : I/O를 하기 위한 여러 장치가 있는데, 각 장치를 기다리는 큐가 각각 존재한다.
  
위와 같이 여러 큐가 존재하는데, 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 **PCB**가 저장되어 있다. 그리고 이러한 순서를 기다리는 공간이 있다면 이 순서를 정해주는 알고리즘이 있어야 한다. 이러한 알고리즘을 **스케줄링(Scheduling)** 이라 한다.
- Job Queue - Job Scheduler(Long-term scheduler)
- Ready Queue - CPU Scheduler(Short-term scheduler)
- Device Queue - Device Scheduler
  
Job queue의 순서를 정해주는 job scheduler를 long-term scheduler라고도 하는데, 이는 이 스케줄링이 발생하는 시간이 비교적 오래걸리기 때문이다.(대략 초~분) 반면에 ready queue의 스케줄러를 short-term scheduler라고도 하는데, 이는 스케줄링이 발생하는 시간이 매우 짧기 때문이다. CPU scheduling은 말 그대로 프로세스가 CPU를 점유하는 순서를 정해주는데 이는 매우 빠른 시간안에 이루어져야한다. 현대 컴퓨터가 여러 프로그램을 동시에 사용하는 것과 같은 효과를 주는 이유가 이 스케줄링 속도가 매우 빠르게 이루어지기 때문이다.
</br>

### (2). 멀티프로그래밍(Multiprogramming)
멀티프로그래밍은 단일 프로세서(CPU) 환경에서 여러 **개의 프로세스가 동시에 실행**되는 것을 말한다.(실제로 동시에 실행되지는 않음) 여러 프로세스가 실행되려면 이 프로세스들은 모두 메인 메모리에 존재하고 있어야 한다. 멀티프로그래밍에 관한 몇 가지 용어와 개념에 대해 살펴보자.
</br>

#### {2.1}. Degree of multiprogramming
Degree of multiprogramming 는 현재 메모리에 할당되어 있는 프로세스 개수를 말한다.
</br>

#### {2.2}. I/O bound process VS CPU bound process
프로세스는 I/O bound process 와 CPU bound process 로 나뉜다.

- I/O bound process: 해당 프로세스에서 I/O(입출력) 작업이 차지는 비중이 높은 프로세스를 말한다.
- CPU bound process: 해당 프로세스에서 CPU 작업(계산)이 차지는 비중이 높은 프로세스를 말한다.

운영체제, 정확히 말하면 job scheduler 는 I/O bound process와 CPU bound process를 적절히 분배해서 메모리에 할당해주어야 한다.
</br>

#### {2.3}. Medium-term scheduler

Medium-term scheduler는 말그대로 short-term보다는 덜 발생하지만, long-term보다는 자주 발생하는 scheduler이다. 하는 일은 운영체제가 실행하는 동안 주기적으로 메인 메모리에 있는 전체 프로세스를 검사하여 보조기억장치로 옮길 프로세스를 찾아 옮긴다. 옮기는 기준은 여러가지 있겠지만 대표적으로 장기간 사용하지 않는 프로세스가 있다.

이 기준으로 동작하는 것이 **Swapping**이다. 이는 메인 메모리에서 장시간 사용하지 않는 프로세스를 하드디스크(**Swap device** = Backing store, 일반적으로 하드디스크는 File system + Backing store 로 구성되어 있다.)로 옮겨주고(**Swap out**), 나중에 이 프로세스가 다시 사용되려고 하면 하드디스크에서 해당 프로세스를 다시 메인 메모리에 할당해준다.(**Swap in**)

Swap out을 통해 메인 메모리의 공간이 생기므로 이를 더욱 효율적으로 사용할 수 있다. 만약 swap out된 프로세스가 다시 swap in으로 메인 메모리에 할당하려고 할 때 **이전의 공간으로 할당되는 것을 보장하지는 않는다**. 왜냐하면 위에 말했듯이 swap out으로 생긴 메모리 공간은 다른 프로세스가 사용할 수 있기 때문이다.
</br>

#### {2.4}. Context Switching(문맥 전환)
Context switching은 CPU가 한 프로세스에서 다른 프로세스로 옮겨가는 것을 말한다. 즉, 한 프로세스가 실행중인 것을 멈추고 다른 프로세스가 실행되는 것이다.

- Scheduler : 여기서 스케줄러는 CPU Scheduler를 말하며, CPU가 어느 프로세스를 선택할지 정한다.
- Dispatcher : 실제 context switching이 발생하면 CPU의 내부 데이터를 이전 프로세스 데이터에서 새로 시작되는 데이터로 바꿔준다. 다시 말해서 현재 CPU 데이터는 이전 프로세스의 PCB에 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원(restore) 해준다.
- __Context switching overhead__ : Context switching이 발생할 때마다, dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것은 overhead이다. 그리고 문맥 전환은 매우 자주 발생하는 작업이므로 overhead를 줄이기 위해서는 dispatcher를 구현하는 코드에 대한 효율을 최대한 높여주어야한다.

## 🔥[5] 쓰레드 
쓰레드와 동시성 (Concurrency)
## 🔥[6] 동시성과 병렬성 이해하기

## 🔥[7] 메모리 관리란? - 이유, 방법
메모리 관리

## 🔥[8] IPC란? - 정의, 종류, 방법
프로세스간 통신 (Interprocess Communication)

## 🔥[9] OS - 입출력 관리
입출력(I/O) 관리

## 🔥[10] POSIX 기초
POSIX 기초

## 🔥[11] 네트워크 기초 지식 정리
stdin, stdout, stderr, pipes
네트워크 기초 개념
## 🔥[12] 네트워크 기초 개념