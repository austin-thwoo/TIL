## MSA
MSA(Microservice Architecture)는 여러 개의 작은 서비스들이 조합되어 전체 시스템을 구성하는 아키텍처 패턴
MSA를 적용하면, 각각의 서비스는 독립적으로 개발 및 배포가 가능하고, 유지보수 및 확장성이 좋아집니다.
##### 모놀리식 구조

1. 부분적 장애 → 전체적 장애로 확대됨
2. 부분적인 scale-out이 어렵다
3. 서비스의 개선이 어렵고, 수정 시 장애의 영향도 파악이 어렵다.
4. 서비스의 전체 코드가 하나의 프로젝트로 구성되어 배포가 오래걸린다.
5. 하나의 framework와 개발언어에 종속되어 서비스에 적절한 기술을 사용하기 어렵다.

##### MSA구조

1. 하나의 서비스 장애가 다른 서비스로 전파되지 않는다.
2. 코드 복잡성 및 의존성을 제거하여 영향도 파악을 용이하게 한다.
3. 서비스의 고 가용성과 확장성을 확보한다.
4. 지속적이고 빠른개발


##### 개발규칙

1. 데이터베이스 서로 공유 x
2. 각각의 레이어들간의 의존성 최소화
3. 정의괸 버전 관리 전략에 따라 안정적이고 문서화되어 있으며 잘 정의된 인터페이스를 통해서만 통신
4. 별도의 런타임 프로세스로 배포 -> 마이크로 서비스의 각 인스턴스는 런타임 프로세스(docker 컨테이너)에서 실행됩니다.
   
   
##### 
msa 
구조 인증, 유저, 게시판


따라서, 인증, 유저, 게시판과 같은 기능들을 서비스로 분리하여 개발하는 것이 좋습니다. 이를 위해, 각각의 서비스는 다음과 같은 구조로 구현될 수 있습니다.

인증 서비스
사용자 인증 및 권한 부여를 담당하는 서비스
사용자 정보 관리, 로그인/로그아웃 처리 등을 담당
OAuth2.0, JWT 등의 인증 방식을 적용하여 보안성을 강화

유저 서비스
사용자 정보를 관리하는 서비스
사용자 프로필, 설정, 관심사 등의 정보를 저장 및 관리
인증 서비스와 연계하여 인증된 사용자 정보를 반환

게시판 서비스
게시물 및 댓글 관리를 담당하는 서비스
CRUD(Create, Read, Update, Delete) 기능을 제공
인증 서비스와 연계하여 권한 검사를 수행
이렇게 각각의 서비스는 독립적으로 개발되며, 각각의 기능을 수행합니다. 각각의 서비스는 RESTful API를 통해 통신하며, 각각의 서비스는 분산환경에서 동작하므로, API 게이트웨이를 통해 클라이언트 요청을 분산 처리하는 것이 좋습니다.

또한, 데이터베이스는 서비스마다 독립적으로 구성하는 것이 좋습니다. 각각의 서비스는 필요한 데이터를 자체적으로 관리하며, 다른 서비스에서는 직접적으로 데이터베이스에 접근하지 않습니다. 대신, RESTful API를 통해 데이터를 주고받는 것이 좋습니다. 이를 통해, 데이터의 무결성을 보장하고, 서비스 간의 결합도를 낮출 수 있습니다.


#### 유저 회원가입과 로그인은 인증 서비스에서
일반적으로 유저의 회원가입과 로그인은 인증 서비스에서 처리하는 것

인증 서비스는 사용자 인증 및 권한 부여를 담당하는 서비스로, 사용자의 로그인 인증 및 세션 관리, 인가 처리 등의 작업을 수행합니다. 따라서, 유저의 회원가입 및 로그인 기능도 인증 서비스에서 처리하면, 이를 통해 인증 관련된 작업을 하나의 서비스에서 처리할 수 있습니다.

또한, 인증 서비스에서 처리하는 유저의 로그인 인증 정보는 JWT(Json Web Token)와 같은 토큰 기반 인증 방식으로 처리하는 것이 좋습니다. 이를 통해, 서비스 간의 인증 정보 공유를 간편하게 할 수 있으며, 보안성도 향상됩니다.





#### 게시판 접속 토큰 유효성검사 
일반적으로 클라이언트에서 로그인 후에 서버에서 발급한 JWT 토큰을 가지고, 게시판 등의 보호된 자원에 접근할 때마다 토큰 검사를 수행하는 것이 일반적입니다.

토큰 검사는 클라이언트에서 수행하며, 인증 서버에 다시 접속해서 유저 확인을 받는 것이 아니라, 클라이언트에서 JWT 토큰의 유효성을 검사하여 인증을 수행합니다. 이를 위해, 클라이언트 측에서는 JWT 토큰 검증 라이브러리를 사용하여 토큰의 유효성을 검사하고, 검증에 성공하면 보호된 자원에 접근하는 요청을 서버에 전송합니다.

따라서, 인증 서버에 접속하는 것보다 토큰 검사를 통해 인증을 수행하는 것이 보다 효율적이며, 서버의 부담도 줄일 수 있습니다.





#### msa 토큰검증을 프론트단에서 한다
MSA에서도 일반적으로 JWT 토큰 기반 인증 방식을 사용하며, 클라이언트 측에서 토큰 검증을 수행하는 것이 일반적입니다.

프론트엔드에서는 JWT 토큰 검증을 위한 라이브러리를 사용하여 토큰의 유효성을 검사하고, 검증에 성공한 경우에만 서버에 API 요청을 보내어 자원에 접근합니다. 이를 통해, 서버에서는 간단한 토큰 검증을 통해 인증을 수행할 뿐만 아니라, 클라이언트 측에서 필요한 인증 정보를 가지고 효율적으로 자원에 접근할 수 있습니다.

따라서, MSA에서도 토큰 검증은 일반적으로 프론트엔드에서 처리하며, 서버에서는 간단한 토큰 검증을 수행하는 것이 일반적입니다.





##### 간단한 토큰 검증이란, 서버에서 JWT 토큰의 유효성을 검사하는 과정

일반적으로 JWT 토큰은 암호화된 형태로 클라이언트에게 전송되며, 클라이언트는 이를 복호화하여 토큰 내에 포함된 정보를 확인합니다. 서버는 이 토큰을 검증하는데, JWT 토큰 내에는 signature라는 필드가 존재하는데, 이 필드는 토큰이 암호화된 방식에 따라 생성된 signature 값입니다. 서버는 이 signature 값을 검증하여 토큰이 유효한지 확인합니다.

간단한 토큰 검증에서는, 서버는 토큰을 복호화하고, signature 값을 검증하여 토큰이 유효한지 여부를 확인합니다. 이 과정은 매우 간단하며, 일반적으로 서버의 부담이 적습니다. 따라서, MSA에서는 이러한 간단한 토큰 검증을 수행하여 보안성을 유지하면서도 서버 부하를 최소화할 수 있습니다.





#### 간단한 토큰검증 == 토큰이 유효한지만 여부를 확인
간단한 토큰 검증에서는, 서버에서는 JWT 토큰을 검증하여 토큰의 발급자, 만료 시간, 그리고 signature 값을 확인하여 토큰이 유효한지 여부를 판단합니다. 따라서, 서버는 간단한 검증만으로도 토큰의 유효성을 검사할 수 있으며, 이를 통해 보안성을 유지하면서도 서버 부하를 최소화할 수 있습니다.

하지만, 간단한 토큰 검증만 수행하는 경우에는, 토큰 내에 포함된 정보 외에는 검증이 수행되지 않습니다. 예를 들어, 서버에서는 토큰의 발급자, 만료 시간, signature 값을 확인할 수 있지만, 토큰 내에 포함된 클레임(Claims) 값의 정합성은 검증할 수 없습니다. 따라서, 보다 엄격한 보안 요구사항을 충족하기 위해서는, 간단한 검증만으로는 부족하며, 더 강력한 보안 메커니즘을 적용해야 합니다.



#### 보안 메커니즘
Spring Boot + JPA로 서버를 구현하는 경우에도, 더 강력한 보안 메커니즘이 필요할 수 있습니다. 이를 구현하는 방법은 다양합니다.

예를 들어, JWT 토큰 기반의 인증을 구현할 때, 클라이언트는 토큰을 발급 받은 후, 이를 Authorization 헤더에 포함시켜 요청을 보냅니다. 서버는 이 토큰을 검증하여 클라이언트가 인증된 사용자인지 확인합니다. 이때, 서버는 토큰을 검증하기 위해 비밀키를 사용합니다. 이 비밀키를 안전하게 보관하고, 토큰을 검증하는 과정에서도 안전하게 사용하는 것이 중요합니다.

또한, 비밀번호를 안전하게 저장하는 방법도 중요합니다. 보통 Spring Security와 같은 보안 프레임워크를 사용하여 비밀번호를 안전하게 저장하고, 인증 과정에서 비밀번호를 안전하게 검증합니다.

또한, 데이터베이스 보안도 중요합니다. 예를 들어, 데이터베이스 연결 시 암호화를 사용하거나, 데이터베이스 취약점을 막기 위해 적절한 보안 설정을 적용하는 것이 필요합니다.

마지막으로, 보안 이슈를 예방하기 위해 코드 검사 및 취약점 분석도 필요합니다. 보안 전문가가 수행하는 코드 검사를 통해 취약점을 사전에 예방할 수 있습니다.





#### 로그인할때 인증서버와 유저서버
로그인 과정에서 인증서버와 유저서버가 주고 받는 정보는 다음과 같습니다.

1. 클라이언트에서 사용자가 입력한 아이디와 비밀번호를 인증서버에 전송합니다.
2. 인증서버는 전달받은 아이디와 비밀번호를 검증하고, 유효한 경우에는 액세스 토큰과 리프레시 토큰을 발급합니다.
3. 액세스 토큰과 리프레시 토큰을 클라이언트에게 전달합니다.
4. 클라이언트는 액세스 토큰을 사용하여 보호된 리소스에 접근할 수 있습니다.
5. 액세스 토큰이 만료된 경우, 클라이언트는 리프레시 토큰을 사용하여 새로운 액세스 토큰을 발급 받습니다.
6. 리프레시 토큰이 만료된 경우, 클라이언트는 다시 로그인 과정을 거쳐 새로운 액세스 토큰과 리프레시 토큰을 발급 받아야 합니다.
   
따라서, 인증서버와 유저서버가 주고 받는 정보는 주로 사용자 인증과 관련된 정보인 아이디와 비밀번호, 액세스 토큰, 리프레시 토큰 등입니다.
일반적으로는 2번 과정에서 인증서버에서 직접 사용자 인증과 토큰 발급을 수행합니다. 따라서 인증서버가 토큰을 발급하면, 해당 토큰은 클라이언트에서 서비스를 호출할 때 사용됩니다.

만약 토큰의 유효성을 검사해야 하는 상황이라면, 클라이언트는 인증서버에 해당 토큰의 유효성을 검사할 요청을 보내고, 인증서버는 해당 토큰이 유효한지 검사한 뒤에 결과를 클라이언트에게 반환합니다. 따라서 유저서버와 직접적으로 연관된 것은 아니며, 토큰의 유효성 검사는 인증서버에서 수행됩니다.
